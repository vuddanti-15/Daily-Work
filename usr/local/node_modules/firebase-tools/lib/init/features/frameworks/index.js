"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createStack = exports.getOrCreateStack = exports.doSetup = void 0;
const clc = require("colorette");
const utils = require("../../../utils");
const logger_1 = require("../../../logger");
const prompt_1 = require("../../../prompt");
const constants_1 = require("./constants");
const repo = require("./repo");
const poller = require("../../../operation-poller");
const api_1 = require("../../../api");
const gcp = require("../../../gcp/frameworks");
const frameworks_1 = require("../../../gcp/frameworks");
const error_1 = require("../../../error");
const frameworksPollerOptions = {
    apiOrigin: api_1.frameworksOrigin,
    apiVersion: frameworks_1.API_VERSION,
    masterTimeout: 25 * 60 * 1000,
    maxBackoff: 10000,
};
async function doSetup(setup, projectId) {
    setup.frameworks = {};
    utils.logBullet("First we need a few details to create your service.");
    await (0, prompt_1.promptOnce)({
        name: "serviceName",
        type: "input",
        default: "acme-inc-web",
        message: "Create a name for your service [1-30 characters]",
    }, setup.frameworks);
    await (0, prompt_1.promptOnce)({
        name: "region",
        type: "list",
        default: constants_1.DEFAULT_REGION,
        message: "Please select a region " +
            `(${clc.yellow("info")}: Your region determines where your backend is located):\n`,
        choices: constants_1.ALLOWED_REGIONS,
    }, setup.frameworks);
    utils.logSuccess(`Region set to ${setup.frameworks.region}.`);
    logger_1.logger.info(clc.bold(`\n${clc.white("===")} Deploy Setup`));
    await (0, prompt_1.promptOnce)({
        name: "deployMethod",
        type: "list",
        default: constants_1.DEFAULT_DEPLOY_METHOD,
        message: "How do you want to deploy",
        choices: constants_1.ALLOWED_DEPLOY_METHODS,
    }, setup.frameworks);
    const stack = await getOrCreateStack(projectId, setup);
    if (stack) {
        utils.logSuccess(`Successfully created a stack: ${stack.name}`);
    }
}
exports.doSetup = doSetup;
function toStack(cloudBuildConnRepo) {
    return {
        codebase: {
            repository: `${cloudBuildConnRepo.name}`,
            rootDirectory: "/",
        },
        labels: {},
    };
}
async function getOrCreateStack(projectId, setup) {
    const location = setup.frameworks.region;
    const deployMethod = setup.frameworks.deployMethod;
    try {
        return await getExistingStack(projectId, setup, location);
    }
    catch (err) {
        if (err.status === 404) {
            logger_1.logger.info("Creating new stack.");
            if (deployMethod === "github") {
                const cloudBuildConnRepo = await repo.linkGitHubRepository(projectId, location);
                const stackDetails = toStack(cloudBuildConnRepo);
                return await createStack(projectId, location, stackDetails, setup.frameworks.serviceName);
            }
        }
        else {
            throw new error_1.FirebaseError(`Failed to get or create a stack using the given initialization details: ${err}`);
        }
    }
    return undefined;
}
exports.getOrCreateStack = getOrCreateStack;
async function getExistingStack(projectId, setup, location) {
    let stack = await gcp.getBackend(projectId, location, setup.frameworks.serviceName);
    while (stack) {
        setup.frameworks.serviceName = undefined;
        await (0, prompt_1.promptOnce)({
            name: "existingStack",
            type: "confirm",
            default: true,
            message: "A stack already exists for the given serviceName, do you want to use existing stack? (yes/no)",
        }, setup.frameworks);
        if (setup.frameworks.existingStack) {
            logger_1.logger.info("Using the existing stack.");
            return stack;
        }
        await (0, prompt_1.promptOnce)({
            name: "serviceName",
            type: "input",
            default: "acme-inc-web",
            message: "Please enter a new service name [1-30 characters]",
        }, setup.frameworks);
        stack = await gcp.getBackend(projectId, location, setup.frameworks.serviceName);
        setup.frameworks.existingStack = undefined;
    }
    return stack;
}
async function createStack(projectId, location, stackReqBoby, stackId) {
    const op = await gcp.createStack(projectId, location, stackReqBoby, stackId);
    const stack = await poller.pollOperation(Object.assign(Object.assign({}, frameworksPollerOptions), { pollerName: `create-${projectId}-${location}-${stackId}`, operationResourceName: op.name }));
    return stack;
}
exports.createStack = createStack;
